using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Xml.Linq;
using System.Runtime.Serialization;
using System.IO;
using System.Text;


namespace Ophelia.Linq.Serialization
{
	public partial class ExpressionSerializer
	{
		/*
	   * DESERIALIZATION 
	   */

		public Expression Deserialize(XElement xml)
		{
			parameters.Clear();
			return ParseExpressionFromXmlNonNull(xml);
		}

		public Expression<TDelegate> Deserialize<TDelegate>(XElement xml)
		{
			Expression e = Deserialize(xml);
			if (e is Expression<TDelegate>)
				return e as Expression<TDelegate>;
			throw new Exception("xml must represent an Expression<TDelegate>");
		}

		private Expression ParseExpressionFromXml(XElement xml)
		{
			if (xml.IsEmpty)
				return null;

			return ParseExpressionFromXmlNonNull(xml.Elements().First());
		}

		private Expression ParseExpressionFromXmlNonNull(XElement xml)
		{
			Expression expression;
			if (TryCustomDeserializers(xml, out expression))
				return expression;

			if (expression != null)
				return expression;
			switch (xml.Name.LocalName)
			{
				case "BinaryExpression":
					return ParseBinaryExpresssionFromXml(xml);
				case "ConstantExpression":
				case "TypedConstantExpression":
					return ParseConstantExpressionFromXml(xml);
				case "ParameterExpression":
					return ParseParameterExpressionFromXml(xml);
				case "LambdaExpression":
					return ParseLambdaExpressionFromXml(xml);
				case "MethodCallExpression":
					return ParseMethodCallExpressionFromXml(xml);
				case "UnaryExpression":
					return ParseUnaryExpressionFromXml(xml);
				case "MemberExpression":
				case "FieldExpression":
				case "PropertyExpression":
					return ParseMemberExpressionFromXml(xml);
				case "NewExpression":
					return ParseNewExpressionFromXml(xml);
				case "ListInitExpression":
					return ParseListInitExpressionFromXml(xml);
				case "MemberInitExpression":
					return ParseMemberInitExpressionFromXml(xml);
				case "ConditionalExpression":
					return ParseConditionalExpressionFromXml(xml);
				case "NewArrayExpression":
					return ParseNewArrayExpressionFromXml(xml);
				case "TypeBinaryExpression":
					return ParseTypeBinaryExpressionFromXml(xml);
				case "InvocationExpression":
					return ParseInvocationExpressionFromXml(xml);
				default:
					throw new NotSupportedException(xml.Name.LocalName);
			}
		}

		/// <summary>
		/// Uses first applicable custom deserializer, then returns.
		/// Does not attempt to use all custom deserializers.
		/// </summary>
		/// <param name="xml"></param>
		/// <param name="result"></param>
		/// <returns></returns>
		private bool TryCustomDeserializers(XElement xml, out  Expression result)
		{
			result = null;			
			int i = 0;
			while (i < this.Converters.Count)
			{
				if (this.Converters[i].TryDeserialize(xml, out result))
					return true;
				i++;
			}
			return false;
		}

		private Expression ParseInvocationExpressionFromXml(XElement xml)
		{
			Expression expression = ParseExpressionFromXml(xml.Element("Expression"));
			var arguments = ParseExpressionListFromXml<Expression>(xml, "Arguments");
			return Expression.Invoke(expression, arguments);
		}

		private Expression ParseTypeBinaryExpressionFromXml(XElement xml)
		{
			Expression expression = ParseExpressionFromXml(xml.Element("Expression"));
			Type typeOperand = ParseTypeFromXml(xml.Element("TypeOperand"));
			return Expression.TypeIs(expression, typeOperand);
		}

		private Expression ParseNewArrayExpressionFromXml(XElement xml)
		{
			Type type = ParseTypeFromXml(xml.Element("Type"));
			if (!type.IsArray)
				throw new Exception("Expected array type");
			Type elemType = type.GetElementType();
			var expressions = ParseExpressionListFromXml<Expression>(xml, "Expressions");
			switch (xml.Attribute("NodeType").Value)
			{
				case "NewArrayInit":
					return Expression.NewArrayInit(elemType, expressions);
				case "NewArrayBounds":
					return Expression.NewArrayBounds(elemType, expressions);
				default:
					throw new Exception("Expected NewArrayInit or NewArrayBounds");
			}
		}

		private Expression ParseConditionalExpressionFromXml(XElement xml)
		{
			Expression test = ParseExpressionFromXml(xml.Element("Test"));
			Expression ifTrue = ParseExpressionFromXml(xml.Element("IfTrue"));
			Expression ifFalse = ParseExpressionFromXml(xml.Element("IfFalse"));
			return Expression.Condition(test, ifTrue, ifFalse);
		}

		private Expression ParseMemberInitExpressionFromXml(XElement xml)
		{
			NewExpression newExpression = ParseNewExpressionFromXml(xml.Element("NewExpression").Element("NewExpression")) as NewExpression;
			var bindings = ParseBindingListFromXml(xml, "Bindings").ToArray();
			return Expression.MemberInit(newExpression, bindings);
		}



		private Expression ParseListInitExpressionFromXml(XElement xml)
		{
			NewExpression newExpression = ParseExpressionFromXml(xml.Element("NewExpression")) as NewExpression;
			if (newExpression == null) throw new Exception("Expceted a NewExpression");
			var initializers = ParseElementInitListFromXml(xml, "Initializers").ToArray();
			return Expression.ListInit(newExpression, initializers);
		}

		private Expression ParseNewExpressionFromXml(XElement xml)
		{
			ConstructorInfo constructor = ParseConstructorInfoFromXml(xml.Element("Constructor"));
			var arguments = ParseExpressionListFromXml<Expression>(xml, "Arguments").ToArray();
			var members = ParseMemberInfoListFromXml<MemberInfo>(xml, "Members").ToArray();
			if (members.Length == 0)
				return Expression.New(constructor, arguments);
			return Expression.New(constructor, arguments, members);
		}

		private Expression ParseMemberExpressionFromXml(XElement xml)
		{
			Expression expression = ParseExpressionFromXml(xml.Element("Expression"));
			MemberInfo member = ParseMemberInfoFromXml(xml.Element("Member"));
			return Expression.MakeMemberAccess(expression, member);
		}

		//Expression ParseFieldExpressionFromXml(XElement xml)
		//{
		//    Expression expression = Expression.Field()
		//}

		private MemberInfo ParseMemberInfoFromXml(XElement xml)
		{
			MemberTypes memberType = (MemberTypes)ParseConstantFromAttribute<MemberTypes>(xml, "MemberType");
			switch (memberType)
			{
				case MemberTypes.Field:
					return ParseFieldInfoFromXml(xml);
				case MemberTypes.Property:
					return ParsePropertyInfoFromXml(xml);
				case MemberTypes.Method:
					return ParseMethodInfoFromXml(xml);
				case MemberTypes.Constructor:
					return ParseConstructorInfoFromXml(xml);
				case MemberTypes.Custom:
				case MemberTypes.Event:
				case MemberTypes.NestedType:
				case MemberTypes.TypeInfo:
				default:
					throw new NotSupportedException(string.Format("MEmberType {0} not supported", memberType));
			}

		}

		private MemberInfo ParseFieldInfoFromXml(XElement xml)
		{
			string fieldName = (string)ParseConstantFromAttribute<string>(xml, "FieldName");
			Type declaringType = ParseTypeFromXml(xml.Element("DeclaringType"));
			return declaringType.GetField(fieldName);
		}

		private MemberInfo ParsePropertyInfoFromXml(XElement xml)
		{
			string propertyName = (string)ParseConstantFromAttribute<string>(xml, "PropertyName");
			Type declaringType = ParseTypeFromXml(xml.Element("DeclaringType"));
			var ps = from paramXml in xml.Element("IndexParameters").Elements()
					 select ParseTypeFromXml(paramXml);
			return declaringType.GetProperty(propertyName);
		}

		private Expression ParseUnaryExpressionFromXml(XElement xml)
		{
			Expression operand = ParseExpressionFromXml(xml.Element("Operand"));
			MethodInfo method = ParseMethodInfoFromXml(xml.Element("Method"));
			var isLifted = (bool)ParseConstantFromAttribute<bool>(xml, "IsLifted");
			var isLiftedToNull = (bool)ParseConstantFromAttribute<bool>(xml, "IsLiftedToNull");
			var expressionType = (ExpressionType)ParseConstantFromAttribute<ExpressionType>(xml, "NodeType");
			var type = ParseTypeFromXml(xml.Element("Type"));
			// Why can't we use IsLifted and IsLiftedToNull here?  
			// May need to special case a nodeType if it needs them.
			return Expression.MakeUnary(expressionType, operand, type, method);
		}

		private Expression ParseMethodCallExpressionFromXml(XElement xml)
		{
			Expression instance = ParseExpressionFromXml(xml.Element("Object"));
			MethodInfo method = ParseMethodInfoFromXml(xml.Element("Method"));
			IEnumerable<Expression> arguments = ParseExpressionListFromXml<Expression>(xml, "Arguments");
			if (arguments == null || arguments.Count() == 0)
				arguments = new Expression[0];
			if (instance == null)//static method
			{
				return Expression.Call(method: method, arguments: arguments);
			}
			else
				return Expression.Call(instance, method, arguments);
		}

		private Expression ParseLambdaExpressionFromXml(XElement xml)
		{
			var body = ParseExpressionFromXml(xml.Element("Body"));
			var parameters = ParseExpressionListFromXml<ParameterExpression>(xml, "Parameters");
			var type = ParseTypeFromXml(xml.Element("Type"));
			// We may need to 
			//var lambdaExpressionReturnType = type.GetMethod("Invoke").ReturnType;
			//if (lambdaExpressionReturnType.IsArray)
			//{

			//    type = typeof(IEnumerable<>).MakeGenericType(type.GetElementType());
			//}
			return Expression.Lambda(type, body, parameters);
		}

		private IEnumerable<T> ParseExpressionListFromXml<T>(XElement xml, string elemName) where T : Expression
		{
			IEnumerable<XElement> elements = xml.Elements(elemName).Elements();
			List<T> list = new List<T>();
			foreach (XElement tXml in elements)
			{
				object parsed = ParseExpressionFromXmlNonNull(tXml);
				list.Add((T)parsed);
			}
			return list;
			//return from tXml in xml.Element(elemName).Elements()
			//       select (T)ParseExpressionFromXmlNonNull(tXml);
		}

		private IEnumerable<T> ParseMemberInfoListFromXml<T>(XElement xml, string elemName) where T : MemberInfo
		{
			return from tXml in xml.Element(elemName).Elements()
				   select (T)ParseMemberInfoFromXml(tXml);
		}

		private IEnumerable<ElementInit> ParseElementInitListFromXml(XElement xml, string elemName)
		{
			return from tXml in xml.Element(elemName).Elements()
				   select ParseElementInitFromXml(tXml);
		}

		private ElementInit ParseElementInitFromXml(XElement xml)
		{
			MethodInfo addMethod = ParseMethodInfoFromXml(xml.Element("AddMethod"));
			var arguments = ParseExpressionListFromXml<Expression>(xml, "Arguments");
			return Expression.ElementInit(addMethod, arguments);

		}

		private IEnumerable<MemberBinding> ParseBindingListFromXml(XElement xml, string elemName)
		{
			return from tXml in xml.Element(elemName).Elements()
				   select ParseBindingFromXml(tXml);
		}

		private MemberBinding ParseBindingFromXml(XElement tXml)
		{
			MemberInfo member = ParseMemberInfoFromXml(tXml.Element("Member"));
			switch (tXml.Name.LocalName)
			{
				case "MemberAssignment":
					Expression expression = ParseExpressionFromXml(tXml.Element("Expression"));
					return Expression.Bind(member, expression);
				case "MemberMemberBinding":
					var bindings = ParseBindingListFromXml(tXml, "Bindings");
					return Expression.MemberBind(member, bindings);
				case "MemberListBinding":
					var initializers = ParseElementInitListFromXml(tXml, "Initializers");
					return Expression.ListBind(member, initializers);
			}
			throw new NotImplementedException();
		}


		private Expression ParseParameterExpressionFromXml(XElement xml)
		{
			Type type = ParseTypeFromXml(xml.Element("Type"));
			string name = (string)ParseConstantFromAttribute<string>(xml, "Name");
			//vs: hack
			string id = name + type.FullName;
			if (!parameters.ContainsKey(id))
				parameters.Add(id, Expression.Parameter(type, name));
			return parameters[id];
		}

		private Expression ParseConstantExpressionFromXml(XElement xml)
		{
			Type type = ParseTypeFromXml(xml.Element("Type"));

			//I changed this to handle Linq.EnumerableQuery: 
			//now the return Type may not necessarily match the type parsed from XML,
			dynamic result = ParseConstantFromElement(xml, "Value", type);
			return Expression.Constant(result, result.GetType());
			//return Expression.Constant(result, type);
		}

		private Type ParseTypeFromXml(XElement xml)
		{
			Debug.Assert(xml.Elements().Count() == 1);
			return ParseTypeFromXmlCore(xml.Elements().First());
		}

		private Type ParseTypeFromXmlCore(XElement xml)
		{
			switch (xml.Name.ToString())
			{
				case "Type":
					return ParseNormalTypeFromXmlCore(xml);
				case "AnonymousType":
					return ParseAnonymousTypeFromXmlCore(xml);
				default:
					throw new ArgumentException("Expected 'Type' or 'AnonymousType'");
			}

		}

		private Type ParseNormalTypeFromXmlCore(XElement xml)
		{
			if (!xml.HasElements)
				return resolver.GetType(xml.Attribute("Name").Value);

			var genericArgumentTypes = from genArgXml in xml.Elements()
									   select ParseTypeFromXmlCore(genArgXml);
			return resolver.GetType(xml.Attribute("Name").Value, genericArgumentTypes);
		}

		private Type ParseAnonymousTypeFromXmlCore(XElement xElement)
		{
			string name = xElement.Attribute("Name").Value;
			var properties = from propXml in xElement.Elements("Property")
							 select new TypeResolver.NameTypePair
							 {
								 Name = propXml.Attribute("Name").Value,
								 Type = ParseTypeFromXml(propXml)
							 };
			var ctr_params = from propXml in xElement.Elements("Constructor").Elements("Parameter")
							 select new TypeResolver.NameTypePair
							 {
								 Name = propXml.Attribute("Name").Value,
								 Type = ParseTypeFromXml(propXml)
							 };

			return resolver.GetOrCreateAnonymousTypeFor(name, properties.ToArray(), ctr_params.ToArray());
		}

		private Expression ParseBinaryExpresssionFromXml(XElement xml)
		{
			var expressionType = (ExpressionType)ParseConstantFromAttribute<ExpressionType>(xml, "NodeType"); ;
			var left = ParseExpressionFromXml(xml.Element("Left"));
			var right = ParseExpressionFromXml(xml.Element("Right"));

			if (left.Type != right.Type)
				ParseBinaryExpressionConvert(ref left, ref right);

			var isLifted = (bool)ParseConstantFromAttribute<bool>(xml, "IsLifted");
			var isLiftedToNull = (bool)ParseConstantFromAttribute<bool>(xml, "IsLiftedToNull");
			var type = ParseTypeFromXml(xml.Element("Type"));
			var method = ParseMethodInfoFromXml(xml.Element("Method"));
			LambdaExpression conversion = ParseExpressionFromXml(xml.Element("Conversion")) as LambdaExpression;
			if (expressionType == ExpressionType.Coalesce)
				return Expression.Coalesce(left, right, conversion);			
			return Expression.MakeBinary(expressionType, left, right, isLiftedToNull, method);
		}

		void ParseBinaryExpressionConvert(ref Expression left, ref Expression right)
		{
			if (left.Type != right.Type)
			{
				UnaryExpression unary;
				//LambdaExpression lambda;
				if (right is ConstantExpression)
				{
					unary = Expression.Convert(left, right.Type);
					left = unary;
				}
				else //(left is ConstantExpression)				
				{
					unary = Expression.Convert(right, left.Type);
					right = unary;
				}
				//lambda = Expression.Lambda(unary);
				//Delegate fn = lambda.Compile();
				//var result = fn.DynamicInvoke(new object[0]);
			}
		}

		private MethodInfo ParseMethodInfoFromXml(XElement xml)
		{
			if (xml.IsEmpty)
				return null;
			string name = (string)ParseConstantFromAttribute<string>(xml, "MethodName");
			Type declaringType = ParseTypeFromXml(xml.Element("DeclaringType"));
			var ps = from paramXml in xml.Element("Parameters").Elements()
					 select ParseTypeFromXml(paramXml);
			var genArgs = from argXml in xml.Element("GenericArgTypes").Elements()
						  select ParseTypeFromXml(argXml);
			return resolver.GetMethod(declaringType, name, ps.ToArray(), genArgs.ToArray());
		}

		private ConstructorInfo ParseConstructorInfoFromXml(XElement xml)
		{
			if (xml.IsEmpty)
				return null;
			Type declaringType = ParseTypeFromXml(xml.Element("DeclaringType"));
			var ps = from paramXml in xml.Element("Parameters").Elements()
					 select ParseParameterFromXml(paramXml);
			ConstructorInfo ci = declaringType.GetConstructor(ps.ToArray());
			return ci;
		}

		private Type ParseParameterFromXml(XElement xml)
		{
			string name = (string)ParseConstantFromAttribute<string>(xml, "Name");
			Type type = ParseTypeFromXml(xml.Element("Type"));
			return type;

		}

		private object ParseConstantFromAttribute<T>(XElement xml, string attrName)
		{
			string objectStringValue = xml.Attribute(attrName).Value;
			if (typeof(Type).IsAssignableFrom(typeof(T)))
				throw new Exception("We should never be encoding Types in attributes now.");
			if (typeof(Enum).IsAssignableFrom(typeof(T)))
				return Enum.Parse(typeof(T), objectStringValue, false);
			return Convert.ChangeType(objectStringValue, typeof(T), default(IFormatProvider));
		}

		private object ParseConstantFromAttribute(XElement xml, string attrName, Type type)
		{
			string objectStringValue = xml.Attribute(attrName).Value;
			if (typeof(Type).IsAssignableFrom(type))
				throw new Exception("We should never be encoding Types in attributes now.");
			if (typeof(Enum).IsAssignableFrom(type))
				return Enum.Parse(type, objectStringValue, false);
			return Convert.ChangeType(objectStringValue, type, default(IFormatProvider));
		}

		/// <summary>
		/// returns object for use in a call to Expression.Constant(object, Type)
		/// </summary>
		/// <param name="xml"></param>
		/// <param name="elemName"></param>
		/// <param name="expectedType"></param>
		/// <returns></returns>
		private object ParseConstantFromElement(XElement xml, string elemName, Type expectedType)
		{

			string objectStringValue = xml.Element(elemName).Value;
			if (typeof(Type).IsAssignableFrom(expectedType))
				return ParseTypeFromXml(xml.Element("Value"));
			if (typeof(Enum).IsAssignableFrom(expectedType))
				return Enum.Parse(expectedType, objectStringValue, false);
			return Convert.ChangeType(objectStringValue, expectedType, default(IFormatProvider));
		}
	}
}